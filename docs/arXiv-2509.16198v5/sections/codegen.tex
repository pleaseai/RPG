\vspace*{-5pt}
\section{Graph-Guided Code Generation}
\label{sec:codegen}
As shown in Figure~\ref{fig:pipeline}(D), given a user query and the completed \graph{}, \ours{} generates repositories by traversing the graph in topological order, ensuring dependencies are implemented before dependents. At each leaf node, test-driven development (TDD) is applied: a test is derived from the task specification, after which the corresponding functions or classes are implemented and validated against it; failing cases trigger revisions until the test passes. Only functions that pass all tests are committed to the repository, enabling incremental expansion while preserving stability. Additional details are provided in Appendix~\ref{app:codegen-details}.
\vspace*{-5pt}
\paragraph{Graph-Guided Localization and Editing}
To handle implementation and debugging requests, we adopt a two-stage workflow: first localizing the target in the \graph{}, then editing the associated code. Localization leverages the graph’s global structure and three complementary tools: (1) \textbf{\graph{}-Guided search}, which uses functionality-based fuzzy matching to identify candidate definitions; (2) \textbf{repository code view}, retrieving full interface bodies for inspection or modification; and (3) \textbf{dependency exploration}, tracing edges to reveal related modules and interactions. Once localized, the agent revises or generates the corresponding code to complete the requested implementation or repair.
\vspace*{-5pt}
\paragraph{Graph-Guided Test Validation}
To ensure correctness and contain errors early, validation follows a staged workflow aligned with the graph. Each function or class is first verified in isolation through unit tests automatically derived from its docstring. Validated components trigger regression tests upon modification, while completed subgraphs undergo integration tests to ensure consistent data flows and contracts across modules. A lightweight majority-vote diagnosis distinguishes genuine implementation errors from environment or test issues, automatically handling the latter and returning the former for repair through the localization–editing workflow.
